/* automatically generated by rust-bindgen 0.69.4 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const _status_STATUS_OK: _status = 0;
pub const _status_STATUS_UNSUPPORTED_CERT_FORMAT: _status = 1;
pub const _status_STATUS_SGX_ROOT_CA_MISSING: _status = 2;
pub const _status_STATUS_SGX_ROOT_CA_INVALID: _status = 3;
pub const _status_STATUS_SGX_ROOT_CA_INVALID_EXTENSIONS: _status = 4;
pub const _status_STATUS_SGX_ROOT_CA_INVALID_ISSUER: _status = 5;
pub const _status_STATUS_SGX_ROOT_CA_UNTRUSTED: _status = 6;
pub const _status_STATUS_SGX_INTERMEDIATE_CA_MISSING: _status = 7;
pub const _status_STATUS_SGX_INTERMEDIATE_CA_INVALID: _status = 8;
pub const _status_STATUS_SGX_INTERMEDIATE_CA_INVALID_EXTENSIONS: _status = 9;
pub const _status_STATUS_SGX_INTERMEDIATE_CA_INVALID_ISSUER: _status = 10;
pub const _status_STATUS_SGX_INTERMEDIATE_CA_REVOKED: _status = 11;
pub const _status_STATUS_SGX_PCK_MISSING: _status = 12;
pub const _status_STATUS_SGX_PCK_INVALID: _status = 13;
pub const _status_STATUS_SGX_PCK_INVALID_EXTENSIONS: _status = 14;
pub const _status_STATUS_SGX_PCK_INVALID_ISSUER: _status = 15;
pub const _status_STATUS_SGX_PCK_REVOKED: _status = 16;
pub const _status_STATUS_TRUSTED_ROOT_CA_INVALID: _status = 17;
pub const _status_STATUS_SGX_PCK_CERT_CHAIN_UNTRUSTED: _status = 18;
pub const _status_STATUS_SGX_TCB_INFO_UNSUPPORTED_FORMAT: _status = 19;
pub const _status_STATUS_SGX_TCB_INFO_INVALID: _status = 20;
pub const _status_STATUS_TCB_INFO_INVALID_SIGNATURE: _status = 21;
pub const _status_STATUS_SGX_TCB_SIGNING_CERT_MISSING: _status = 22;
pub const _status_STATUS_SGX_TCB_SIGNING_CERT_INVALID: _status = 23;
pub const _status_STATUS_SGX_TCB_SIGNING_CERT_INVALID_EXTENSIONS: _status = 24;
pub const _status_STATUS_SGX_TCB_SIGNING_CERT_INVALID_ISSUER: _status = 25;
pub const _status_STATUS_SGX_TCB_SIGNING_CERT_CHAIN_UNTRUSTED: _status = 26;
pub const _status_STATUS_SGX_TCB_SIGNING_CERT_REVOKED: _status = 27;
pub const _status_STATUS_SGX_CRL_UNSUPPORTED_FORMAT: _status = 28;
pub const _status_STATUS_SGX_CRL_UNKNOWN_ISSUER: _status = 29;
pub const _status_STATUS_SGX_CRL_INVALID: _status = 30;
pub const _status_STATUS_SGX_CRL_INVALID_EXTENSIONS: _status = 31;
pub const _status_STATUS_SGX_CRL_INVALID_SIGNATURE: _status = 32;
pub const _status_STATUS_SGX_CA_CERT_UNSUPPORTED_FORMAT: _status = 33;
pub const _status_STATUS_SGX_CA_CERT_INVALID: _status = 34;
pub const _status_STATUS_TRUSTED_ROOT_CA_UNSUPPORTED_FORMAT: _status = 35;
pub const _status_STATUS_MISSING_PARAMETERS: _status = 36;
pub const _status_STATUS_UNSUPPORTED_QUOTE_FORMAT: _status = 37;
pub const _status_STATUS_UNSUPPORTED_PCK_CERT_FORMAT: _status = 38;
pub const _status_STATUS_INVALID_PCK_CERT: _status = 39;
pub const _status_STATUS_UNSUPPORTED_PCK_RL_FORMAT: _status = 40;
pub const _status_STATUS_INVALID_PCK_CRL: _status = 41;
pub const _status_STATUS_UNSUPPORTED_TCB_INFO_FORMAT: _status = 42;
pub const _status_STATUS_PCK_REVOKED: _status = 43;
pub const _status_STATUS_TCB_INFO_MISMATCH: _status = 44;
pub const _status_STATUS_TCB_OUT_OF_DATE: _status = 45;
pub const _status_STATUS_TCB_REVOKED: _status = 46;
pub const _status_STATUS_TCB_CONFIGURATION_NEEDED: _status = 47;
pub const _status_STATUS_TCB_OUT_OF_DATE_CONFIGURATION_NEEDED: _status = 48;
pub const _status_STATUS_TCB_NOT_SUPPORTED: _status = 49;
pub const _status_STATUS_TCB_UNRECOGNIZED_STATUS: _status = 50;
pub const _status_STATUS_UNSUPPORTED_QE_CERTIFICATION: _status = 51;
pub const _status_STATUS_INVALID_QE_CERTIFICATION_DATA_SIZE: _status = 52;
pub const _status_STATUS_UNSUPPORTED_QE_CERTIFICATION_DATA_TYPE: _status = 53;
pub const _status_STATUS_PCK_CERT_MISMATCH: _status = 54;
pub const _status_STATUS_INVALID_QE_REPORT_SIGNATURE: _status = 55;
pub const _status_STATUS_INVALID_QE_REPORT_DATA: _status = 56;
pub const _status_STATUS_INVALID_QUOTE_SIGNATURE: _status = 57;
pub const _status_STATUS_SGX_QE_IDENTITY_UNSUPPORTED_FORMAT: _status = 58;
pub const _status_STATUS_SGX_QE_IDENTITY_INVALID: _status = 59;
pub const _status_STATUS_SGX_QE_IDENTITY_INVALID_SIGNATURE: _status = 60;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_UNSUPPORTED_FORMAT: _status = 61;
pub const _status_STATUS_SGX_ENCLAVE_IDENTITY_UNSUPPORTED_FORMAT: _status = 62;
pub const _status_STATUS_SGX_ENCLAVE_IDENTITY_INVALID: _status = 63;
pub const _status_STATUS_SGX_ENCLAVE_IDENTITY_UNSUPPORTED_VERSION: _status = 64;
pub const _status_STATUS_SGX_ENCLAVE_IDENTITY_OUT_OF_DATE: _status = 65;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_MISCSELECT_MISMATCH: _status = 66;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_ATTRIBUTES_MISMATCH: _status = 67;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_MRENCLAVE_MISMATCH: _status = 68;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_MRSIGNER_MISMATCH: _status = 69;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_ISVPRODID_MISMATCH: _status = 70;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_ISVSVN_OUT_OF_DATE: _status = 71;
pub const _status_STATUS_UNSUPPORTED_QE_IDENTITY_FORMAT: _status = 72;
pub const _status_STATUS_QE_IDENTITY_OUT_OF_DATE: _status = 73;
pub const _status_STATUS_QE_IDENTITY_MISMATCH: _status = 74;
pub const _status_STATUS_SGX_TCB_INFO_EXPIRED: _status = 75;
pub const _status_STATUS_SGX_ENCLAVE_IDENTITY_INVALID_SIGNATURE: _status = 76;
pub const _status_STATUS_INVALID_PARAMETER: _status = 77;
pub const _status_STATUS_SGX_PCK_CERT_CHAIN_EXPIRED: _status = 78;
pub const _status_STATUS_SGX_CRL_EXPIRED: _status = 79;
pub const _status_STATUS_SGX_SIGNING_CERT_CHAIN_EXPIRED: _status = 80;
pub const _status_STATUS_SGX_ENCLAVE_IDENTITY_EXPIRED: _status = 81;
pub const _status_STATUS_TCB_SW_HARDENING_NEEDED: _status = 82;
pub const _status_STATUS_TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED: _status = 83;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_ISVSVN_REVOKED: _status = 84;
pub const _status_STATUS_TDX_MODULE_MISMATCH: _status = 85;
pub const _status_STATUS_SGX_ENCLAVE_REPORT_ISVSVN_NOT_SUPPORTED: _status = 86;
pub const _status_STATUS_TCB_TD_RELAUNCH_ADVISED: _status = 87;
pub const _status_STATUS_TCB_TD_RELAUNCH_ADVISED_CONFIGURATION_NEEDED: _status = 88;
#[doc = " List of possible status code values of the Quote Verification Library functions.\n Status codes indicate the result of an operation."]
pub type _status = ::std::os::raw::c_uint;
#[doc = " List of possible status code values of the Quote Verification Library functions.\n Status codes indicate the result of an operation."]
pub use self::_status as Status;
#[link(name = "QuoteVerificationd", kind = "dylib")]
extern "C" {
    #[doc = " This function is responsible for verifying provided quote against PCK certificates.\n\n @param quote - Buffer with serialized quote structure.\n @param quoteSize - Size of quote buffer. Function heavily relies on this input as internal buffer is allocated based on it without boundaries check! It's user responsibility to provide proper validation.\n @param pemPckCertificate - Null terminated Intel SGX PCK certificate in PEM format.\n @param intermediateCrl - Null terminated, PEM or DER(hex encoded) formatted x.509 Intel SGX PCK Processor/Platform CRL\n @param tcbInfoJson - TCB Info structure in JSON format signed by Intel SGX TCB Signing Certificate.\n @param qeIdentityJson - QE Identity structure in JSON format signed by Intel SGX TCB Signing Certificate.\n @return Status code of the operation, one of:\n      - STATUS_OK\n      - STATUS_MISSING_PARAMETERS\n      - STATUS_UNSUPPORTED_QUOTE_FORMAT\n      - STATUS_UNSUPPORTED_PCK_CERT_FORMAT\n      - STATUS_INVALID_PCK_CERT\n      - STATUS_UNSUPPORTED_PCK_RL_FORMAT\n      - STATUS_INVALID_PCK_RL\n      - STATUS_PCK_REVOKED\n      - STATUS_UNSUPPORTED_TCB_INFO_FORMAT\n      - STATUS_TCB_INFO_MISMATCH\n      - STATUS_TCB_OUT_OF_DATE\n      - STATUS_TCB_REVOKED\n      - STATUS_TCB_CONFIGURATION_NEEDED\n      - STATUS_TCB_OUT_OF_DATE_CONFIGURATION_NEEDED\n      - STATUS_TCB_SW_HARDENING_NEEDED\n      - STATUS_TCB_CONFIGURATION_AND_SW_HARDENING_NEEDED\n      - STATUS_TCB_NOT_SUPPORTED\n      - STATUS_TCB_UNRECOGNIZED_STATUS\n      - STATUS_TCB_TD_RELAUNCH_ADVISED\n      - STATUS_TCB_TD_RELAUNCH_ADVISED_CONFIGURATION_NEEDED\n      - STATUS_INVALID_QE_REPORT_SIGNATURE\n      - STATUS_INVALID_QE_REPORT_DATA\n      - STATUS_UNSUPPORTED_QE_IDENTITY_FORMAT\n      - STATUS_QE_IDENTITY_MISMATCH\n      - STATUS_INVALID_QUOTE_SIGNATURE"]
    pub fn sgxAttestationVerifyQuote(
        quote: *const u8,
        quoteSize: u32,
        pemPckCertificate: *const ::std::os::raw::c_char,
        intermediateCrl: *const ::std::os::raw::c_char,
        tcbInfoJson: *const ::std::os::raw::c_char,
        qeIdentityJson: *const ::std::os::raw::c_char,
    ) -> Status;
}
extern "C" {
    #[doc = " @param enclaveReport - Buffer with serialized Enclave Report  structure.\n @param enclaveIdentity - Enclave Identity structure in JSON format.\n @return Status code of the operation, one of:\n      - STATUS_OK\n      - STATUS_SGX_ENCLAVE_REPORT_UNSUPPORTED_FORMAT\n      - STATUS_SGX_ENCLAVE_IDENTITY_UNSUPPORTED_FORMAT\n      - STATUS_SGX_ENCLAVE_IDENTITY_INVALID\n      - STATUS_SGX_ENCLAVE_IDENTITY_UNSUPPORTED_VERSION\n      - STATUS_SGX_ENCLAVE_REPORT_MISCSELECT_MISMATCH\n      - STATUS_SGX_ENCLAVE_REPORT_ATTRIBUTES_MISMATCH\n      - STATUS_SGX_ENCLAVE_REPORT_MRSIGNER_MISMATCH\n      - STATUS_SGX_ENCLAVE_REPORT_ISVPRODID_MISMATCH\n      - STATUS_SGX_ENCLAVE_REPORT_ISVSVN_OUT_OF_DATE\n      - STATUS_SGX_ENCLAVE_REPORT_ISVSVN_REVOKED"]
    pub fn sgxAttestationVerifyEnclaveReport(
        enclaveReport: *const u8,
        enclaveIdentity: *const ::std::os::raw::c_char,
    ) -> Status;
}
extern "C" {
    #[doc = " This function returns version information.\n\n @return Returned c-string includes:\n  \t- API version (changed when Quote Verification Library API is modified)"]
    pub fn sgxAttestationGetVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " This function returns version information (Supported by SGX Enclave)\n @param [OUT] version - Provided buffer that output will be copied to.\n                        Returned c-string includes:\n  \t- API version (changed when Quote Verification Library API is modified)\n @param len - size of the provided buffer\n @return void"]
    pub fn sgxEnclaveAttestationGetVersion(version: *mut ::std::os::raw::c_char, len: usize);
}
extern "C" {
    #[doc = " This function returns size of QE Certification Data (part of Quote Auth Data) retrieved from provided Quote.\n @param quote - Buffer with serialized quote structure.\n @param quoteSize - Size of quote buffer. Function heavily relies on this input as internal buffer is allocated based on it without boundaries check! It's user responsibility to provide proper validation.\n @param qeCertificateDataSize - Size of QE Certification Data retrieved from Quote. Out parameter - will hold the size.\n @return Status code of the operation. One of:\n      - STATUS_OK\n      - STATUS_MISSING_PARAMETERS\n      - STATUS_UNSUPPORTED_QUOTE_FORMAT"]
    pub fn sgxAttestationGetQECertificationDataSize(
        quote: *const u8,
        quoteSize: u32,
        qeCertificationDataSize: *mut u32,
    ) -> Status;
}
extern "C" {
    #[doc = " This function returns QE Certification Data Type and buffer with QE Certification Data retrieved from provided Quote.\n\n @param quote - Buffer with serialized quote structure.\n @param quoteSize - Size of quote buffer. Function heavily relies on this input as internal buffer is allocated based on it without boundaries check! It's user responsibility to provide proper validation.\n @param qeCertificateDataSize - Size of QE Certification Data retrieved from Quote.\n @param qeCertificationData - Reference to buffer for QE Certification Data retrieved from Quote. Out parameter - will hold extracted QE Cert data.\n @param qeCertificationDataType - Enum representing type of QE Certification Data. Out parameter - will hold the type. One of:\n      - Plain PCK ID (1)\n      - Encrypted PCK ID (2)\n      - PCK Certificate (3)\n @return Status code of the operation. One of:\n      - STATUS_OK\n      - STATUS_MISSING_PARAMETERS\n      - STATUS_UNSUPPORTED_QUOTE_FORMAT\n      - STATUS_INVALID_QE_CERTIFICATION_DATA_SIZE"]
    pub fn sgxAttestationGetQECertificationData(
        quote: *const u8,
        quoteSize: u32,
        qeCertificationDataSize: u32,
        qeCertificationData: *mut u8,
        qeCertificationDataType: *mut u16,
    ) -> Status;
}
extern "C" {
    #[doc = " This function is responsible for verifying if provided PCK Certificate Chain is valid.\n\n @param pemCertChain - Null terminated string containing x.509 certificates in PEM format concatenated together:\n      - Intel SGX Root CA certificate\n      - Intel SGX PCK Platform or Processor CA certificate\n      - Intel SGX PCK certificate\n @param crls - Table with two, null terminated PEM formatted x.509 CRLs. Function will try to access two indexes:\n      - crls[0] - PEM or DER(hex encoded) formatted CRL issued by root CA\n      - crls[1] - PEM or DER(hex encoded) formatted CRL issued by intermediate certificate.\n @param pemRootCaCertificate - Null terminated Intel SGX Root CA certificate (x.509, self-signed) in PEM format.\n @param expirationCheckDate - Time stamp used to verify if the certificates & CRLs have not expired\n        (i.e. if the expiration date specified in the certificate/CRL has not exceeded provided Expiration Check Date).\n        This parameter is optional if the function is executed in SW mode and mandatory if it is executed inside an SGX Enclave.\n @return Status code of the operation. One of:\n      - STATUS_OK\n      - STATUS_INVALID_PARAMETER\n      - STATUS_UNSUPPORTED_CERT_FORMAT\n      - STATUS_SGX_ROOT_CA_MISSING\n      - STATUS_SGX_ROOT_CA_INVALID\n      - STATUS_SGX_ROOT_CA_INVALID_EXTENSIONS\n      - STATUS_SGX_ROOT_CA_INVALID_ISSUER\n      - STATUS_SGX_INTERMEDIATE_CA_MISSING\n      - STATUS_SGX_INTERMEDIATE_CA_INVALID\n      - STATUS_SGX_INTERMEDIATE_CA_INVALID_EXTENSIONS\n      - STATUS_SGX_INTERMEDIATE_CA_INVALID_ISSUER\n      - STATUS_SGX_INTERMEDIATE_CA_REVOKED\n      - STATUS_SGX_PCK_MISSING\n      - STATUS_SGX_PCK_INVALID\n      - STATUS_SGX_PCK_INVALID_EXTENSIONS\n      - STATUS_SGX_PCK_INVALID_ISSUER\n      - STATUS_SGX_PCK_REVOKED\n      - STATUS_TRUSTED_ROOT_CA_INVALID\n      - STATUS_SGX_PCK_CERT_CHAIN_UNTRUSTED\n      - STATUS_SGX_CRL_UNSUPPORTED_FORMAT\n      - STATUS_SGX_CRL_UNKNOWN_ISSUER\n      - STATUS_SGX_CRL_INVALID\n      - STATUS_SGX_CRL_INVALID_EXTENSIONS\n      - STATUS_SGX_CRL_INVALID_SIGNATURE\n      - STATUS_SGX_PCK_CERT_CHAIN_EXPIRED\n      - STATUS_SGX_CRL_EXPIRED"]
    pub fn sgxAttestationVerifyPCKCertificate(
        pemCertChain: *const ::std::os::raw::c_char,
        crls: *const *const ::std::os::raw::c_char,
        pemRootCaCertificate: *const ::std::os::raw::c_char,
        expirationCheckDate: *const time_t,
    ) -> Status;
}
extern "C" {
    #[doc = " This function is responsible for verifying TCB Info structure issued by Intel SGX TCB Signing Certificate.\n\n @param tcbInfo - TCB Info structure in JSON format signed by Intel SGX TCB Signing Certificate.\n @param pemCertChain - x.509 TCB Signing Certificate chain (that signed provided TCBInfo) in PEM format concatenated together.\n @param rootCaCrl - x.509 SGX Root CA CRL in PEM or DER(hex encoded) format.\n @param pemRootCaCertificate - Intel SGX Root CA certificate (x.509, self-signed) in PEM format.\n @param expirationCheckDate - Time stamp used to verify if the certificates & CRLs have not expired\n        (i.e. if the expiration date specified in the certificate/CRL has not exceeded provided Expiration Check Date).\n        This parameter is optional if the function is executed in SW mode and mandatory if it is executed inside an SGX Enclave.\n @return Status code of the operation. One of:\n      - STATUS_OK\n      - STATUS_INVALID_PARAMETER\n      - STATUS_UNSUPPORTED_CERT_FORMAT\n      - STATUS_SGX_TCB_INFO_INVALID\n      - STATUS_TCB_INFO_INVALID_SIGNATURE\n      - STATUS_UNSUPPORTED_CERT_FORMAT\n      - STATUS_SGX_ROOT_CA_MISSING\n      - STATUS_SGX_ROOT_CA_INVALID\n      - STATUS_SGX_ROOT_CA_INVALID_EXTENSIONS\n      - STATUS_SGX_ROOT_CA_INVALID_ISSUER\n      - STATUS_SGX_INTERMEDIATE_CA_MISSING\n      - STATUS_SGX_INTERMEDIATE_CA_INVALID\n      - STATUS_SGX_INTERMEDIATE_CA_INVALID_EXTENSIONS\n      - STATUS_SGX_INTERMEDIATE_CA_INVALID_ISSUER\n      - STATUS_SGX_INTERMEDIATE_CA_REVOKED\n      - STATUS_TRUSTED_ROOT_CA_INVALID\n      - STATUS_SGX_PCK_CERT_CHAIN_UNTRUSTED\n      - STATUS_SGX_CRL_UNSUPPORTED_FORMAT\n      - STATUS_SGX_CRL_UNKNOWN_ISSUER\n      - STATUS_SGX_CRL_INVALID\n      - STATUS_SGX_CRL_INVALID_EXTENSIONS\n      - STATUS_SGX_CRL_INVALID_SIGNATURE\n      - STATUS_SGX_TCB_INFO_EXPIRED\n      - STATUS_SGX_SIGNING_CERT_CHAIN_EXPIRED\n      - STATUS_SGX_CRL_EXPIRED"]
    pub fn sgxAttestationVerifyTCBInfo(
        tcbInfo: *const ::std::os::raw::c_char,
        pemCertChain: *const ::std::os::raw::c_char,
        rootCaCrl: *const ::std::os::raw::c_char,
        pemRootCaCertificate: *const ::std::os::raw::c_char,
        expirationCheckDate: *const time_t,
    ) -> Status;
}
extern "C" {
    #[doc = " This function is responsible for verifying Enclave Identity structure.\n\n @param enclaveIdentityString - Enclave Identity structure in JSON format signed by Intel SGX TCB Signing Certificate.\n @param pemCertChain - x.509 TCB Signing Certificate chain (that signed provided QE Identity) in PEM format concatenated together.\n @param rootCaCrl - x.509 SGX Root CA CRL in PEM or DER(hex encoded) format.\n @param pemRootCaCertificate - Intel SGX Root CA certificate (x.509, self-signed) in PEM format.\n @param expirationCheckDate - Time stamp used to verify if the certificates & CRLs have not expired\n        (i.e. if the expiration date specified in the certificate/CRL has not exceeded provided Expiration Check Date).\n        This parameter is optional if the function is executed in SW mode and mandatory if it is executed inside an SGX Enclave.\n @return Status code of the operation. One of:\n      - STATUS_OK\n      - STATUS_INVALID_PARAMETER\n      - STATUS_SGX_ENCLAVE_IDENTITY_UNSUPPORTED_FORMAT\n      - STATUS_SGX_ENCLAVE_IDENTITY_INVALID\n      - STATUS_SGX_ENCLAVE_IDENTITY_INVALID_SIGNATURE\n      - STATUS_UNSUPPORTED_CERT_FORMAT\n      - STATUS_SGX_ROOT_CA_MISSING\n      - STATUS_SGX_ROOT_CA_INVALID\n      - STATUS_SGX_ROOT_CA_INVALID_EXTENSIONS\n      - STATUS_SGX_ROOT_CA_INVALID_ISSUER\n      - STATUS_SGX_TCB_SIGNING_CERT_MISSING\n      - STATUS_SGX_TCB_SIGNING_CERT_INVALID\n      - STATUS_SGX_TCB_SIGNING_CERT_INVALID_EXTENSIONS\n      - STATUS_SGX_TCB_SIGNING_CERT_INVALID_ISSUER\n      - STATUS_SGX_TCB_SIGNING_CERT_REVOKED\n      - STATUS_TRUSTED_ROOT_CA_INVALID\n      - STATUS_SGX_TCB_SIGNING_CERT_CHAIN_UNTRUSTED\n      - STATUS_SGX_CRL_UNSUPPORTED_FORMAT\n      - STATUS_SGX_CRL_UNKNOWN_ISSUER\n      - STATUS_SGX_CRL_INVALID\n      - STATUS_SGX_CRL_INVALID_EXTENSIONS\n      - STATUS_SGX_CRL_INVALID_SIGNATURE\n      - STATUS_SGX_ENCLAVE_IDENTITY_EXPIRED\n      - STATUS_SGX_SIGNING_CERT_CHAIN_EXPIRED\n      - STATUS_SGX_CRL_EXPIRED"]
    pub fn sgxAttestationVerifyEnclaveIdentity(
        enclaveIdentityString: *const ::std::os::raw::c_char,
        pemCertChain: *const ::std::os::raw::c_char,
        rootCaCrl: *const ::std::os::raw::c_char,
        pemRootCaCertificate: *const ::std::os::raw::c_char,
        expirationCheckDate: *const time_t,
    ) -> Status;
}
extern "C" {
    #[doc = " This function is responsible for verifying Certificate Revocation Lists issued by one of the CA certificates in\n PCK Certificate Chain.\n\n @param crl - Null terminated, PEM formatted x.509 Certificate Revocation Lists supported by PCK Certificate Chain. One of:\n      - Intel SGX Root CA CRL\n      - Intel SGX PCK Platform CRL\n      - Intel SGX PCK Processor CRL\n @param pemCACertChain - x.509 CA certificates (that issued provided CRL) in PEM format concatenated together\n @param pemTrustedRootCaCert - Intel SGX Root CA certificate (x.509, self-signed) in PEM format.\n @return Status code of the operation. One of:\n      - STATUS_OK\n      - STATUS_SGX_CRL_UNSUPPORTED_FORMAT\n      - STATUS_SGX_CRL_UNKNOWN_ISSUER\n      - STATUS_SGX_CRL_INVALID\n      - STATUS_SGX_CRL_INVALID_EXTENSIONS\n      - STATUS_SGX_CRL_INVALID_SIGNATURE\n      - STATUS_SGX_CA_CERT_UNSUPPORTED_FORMAT\n      - STATUS_SGX_CA_CERT_INVALID\n      - STATUS_TRUSTED_ROOT_CA_UNSUPPORTED_FORMAT\n      - STATUS_TRUSTED_ROOT_CA_INVALID\n      - STATUS_SGX_ROOT_CA_UNTRUSTED"]
    pub fn sgxAttestationVerifyPCKRevocationList(
        crl: *const ::std::os::raw::c_char,
        pemCACertChain: *const ::std::os::raw::c_char,
        pemTrustedRootCaCert: *const ::std::os::raw::c_char,
    ) -> Status;
}
extern "C" {
    #[doc = " This function allows user to setup logging in QVL. If fileLogLevel is empty or set to OFF or fileName is empty there\n will be no file logger created.\n @param name\n @param consoleLogLevel\n @param fileLogLevel\n @param fileName\n @param pattern"]
    pub fn sgxAttestationLoggerSetup(
        name: *const ::std::os::raw::c_char,
        consoleLogLevel: *const ::std::os::raw::c_char,
        fileLogLevel: *const ::std::os::raw::c_char,
        fileName: *const ::std::os::raw::c_char,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " This function allows user to set scoped custom field with specified key and value for current processing thread.\n This field will can be used in pattern using %r.\n @param key\n @param value"]
    pub fn sgxAttestationLoggerSetCustomField(
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
